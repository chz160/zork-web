# Data Integration Guide

This document explains how the converted Zork game data is integrated into the game engine.

## Overview

The Zork Web game engine uses a data-driven architecture where game content (rooms, objects) is loaded from JSON files generated by the conversion tool. This approach separates game content from game logic, making it easier to maintain and extend.

## Architecture

### Data Flow

```
Original ZIL Source → Converter Tool → JSON Files → DataLoaderService → GameEngineService
```

1. **Original ZIL Source**: Legacy Zork source code in ZIL format
2. **Converter Tool**: Transforms ZIL to TypeScript/JSON schema
3. **JSON Files**: Converted data stored in `src/app/data/`
4. **DataLoaderService**: Loads and transforms JSON into TypeScript models
5. **GameEngineService**: Uses loaded data to run the game

### Components

#### DataLoaderService

Located at: `src/app/core/services/data-loader.service.ts`

**Responsibilities:**
- Load JSON data files at compile time using static imports
- Convert JSON format to TypeScript interfaces (Room, GameObject)
- Transform plain object exits to Map structures required by the engine

**Key Methods:**
```typescript
loadRooms(): Room[]      // Load all rooms from rooms.json
loadObjects(): GameObject[]  // Load all objects from objects.json
```

**Format Conversion:**
The service handles the conversion from JSON format to TypeScript interfaces:
- `exits: { "north": "room-id" }` → `exits: Map<Direction, string>`
- Validates data structure matches TypeScript interfaces

#### GameEngineService Integration

Located at: `src/app/core/services/game-engine.service.ts`

**Integration Point: `initializeGame()`**

The engine loads all game data when initialized:

```typescript
initializeGame(): void {
  // Load all rooms and objects from converted data
  const rooms = this.dataLoader.loadRooms();
  const objects = this.dataLoader.loadObjects();

  // Populate the game world
  rooms.forEach((room) => this.addRoom(room));
  objects.forEach((obj) => this.addObject(obj));

  // Set the starting room and display welcome message
  // ...
}
```

## Data Files

### rooms.json

**Location:** `src/app/data/rooms.json`

**Structure:**
```json
{
  "rooms": [
    {
      "id": "west-of-house",
      "name": "West Of House",
      "description": "You are standing in an open field...",
      "shortDescription": "West of House",
      "exits": {
        "north": "north-of-house",
        "south": "south-of-house",
        "east": "forest"
      },
      "objectIds": ["mailbox"],
      "visited": false,
      "isDark": false
    }
  ]
}
```

**Statistics:**
- **110 rooms** covering the entire Zork dungeon
- Each room has: unique ID, name, description, exits map, object list

### objects.json

**Location:** `src/app/data/objects.json`

**Structure:**
```json
{
  "objects": [
    {
      "id": "brass-lantern",
      "name": "brass lantern",
      "aliases": ["lantern", "lamp", "light"],
      "description": "A brass lantern is here.",
      "portable": true,
      "visible": true,
      "location": "living-room",
      "properties": {
        "isLight": true,
        "isLit": false
      }
    }
  ]
}
```

**Statistics:**
- **120 objects** including treasures, tools, containers, NPCs
- Each object has: ID, name, aliases, description, flags, location, optional properties

## Usage Examples

### Basic Initialization

```typescript
import { GameEngineService } from './core/services';

@Component({...})
export class GameComponent implements OnInit {
  constructor(private gameEngine: GameEngineService) {}

  ngOnInit() {
    // Load all game data and initialize
    this.gameEngine.initializeGame();
    
    // Game world is now populated with 110 rooms and 120 objects
    const currentRoom = this.gameEngine.getCurrentRoom();
    console.log(`Starting at: ${currentRoom?.name}`);
  }
}
```

### Navigation with Loaded Data

```typescript
import { GameEngineService, CommandParserService } from './core/services';

// Parse and execute commands using the loaded world
const command = parser.parse('north');
const result = gameEngine.executeCommand(command);

if (result.success) {
  // Player moved to a new room from the loaded data
  console.log(result.messages);
}
```

### Object Interactions

```typescript
// Objects are automatically available after initialization
const command = parser.parse('take lantern');
const result = gameEngine.executeCommand(command);

if (result.success) {
  // Object was found in the loaded data and picked up
  console.log(gameEngine.player().inventory);
}
```

## Testing

### Unit Tests

**Data Loader Tests** (`data-loader.service.spec.ts`):
- Validates data loading from JSON files
- Verifies format conversion (exits object → Map)
- Confirms data integrity (required properties, correct types)

```typescript
it('should load at least 100 rooms', () => {
  const rooms = service.loadRooms();
  expect(rooms.length).toBeGreaterThanOrEqual(100);
});
```

### Integration Tests

**Engine Integration Tests** (`game-engine-integration.spec.ts`):
- Tests complete game flow with real data
- Validates room navigation using converted exits
- Verifies object interactions with loaded objects
- Tests command sequences and state management

```typescript
it('should support a sequence of commands using converted data', () => {
  const commands = ['look', 'inventory', 'north'];
  
  commands.forEach((cmdText) => {
    const command = parser.parse(cmdText);
    const result = gameEngine.executeCommand(command);
    expect(result).toBeDefined();
  });
});
```

**Run Tests:**
```bash
npm test
```

Expected: 124 tests passing (includes 13 integration tests)

## Maintenance

### Adding New Rooms/Objects

1. Update the original ZIL source or manually edit JSON files
2. If editing ZIL, re-run the converter:
   ```bash
   npm run convert -- --source docs/original-src-1980 --output src/app/data --overwrite
   ```
3. Data is automatically picked up on next game initialization
4. No code changes needed!

### Data Validation

The converter includes JSON schema validation. To manually validate:

```bash
npm run convert -- --source docs/original-src-1980 --output src/app/data
```

Any validation errors will be reported during conversion.

### Performance Considerations

- **Compile-time imports**: JSON files are bundled at build time
- **One-time load**: Data loaded once during `initializeGame()`
- **Memory efficient**: Uses Maps for O(1) lookups
- **Bundle size**: ~85KB for all game data (minified)

## Troubleshooting

### Common Issues

**Issue: "Room not found" errors**
- Verify room ID exists in `rooms.json`
- Check exit mappings reference valid room IDs
- Ensure data is loaded before executing commands

**Issue: Objects not appearing in rooms**
- Check `objectIds` array in room definitions
- Verify object `location` matches room ID
- Confirm object `visible` flag is `true`

**Issue: Exits not working**
- Verify exits use valid Direction types (north, south, east, west, up, down)
- Check target room IDs exist in loaded data
- Ensure exits Map is properly converted from JSON

### Debug Tips

```typescript
// Check if data is loaded
console.log('Rooms loaded:', gameEngine.getCurrentRoom());

// Inspect specific room
const room = gameEngine.getCurrentRoom();
console.log('Room exits:', Array.from(room.exits.entries()));

// Check object location
const obj = gameEngine.getObject('brass-lantern');
console.log('Object location:', obj?.location);
```

## Future Enhancements

Potential improvements to the integration:

1. **Lazy loading**: Load rooms/objects on-demand to reduce initial bundle size
2. **Data caching**: Cache loaded data in browser storage
3. **Hot reload**: Support updating game data without restarting
4. **Data versioning**: Track data schema versions for compatibility
5. **Compression**: Compress JSON data for smaller bundle size

## Related Documentation

- [Converter Tool Documentation](CONVERTER.md)
- [Data Conversion Status](DATA-CONVERSION-STATUS.md)
- [Entity Mapping Guide](entity-mapping.md)
- [Architecture Documentation](architecture.md)
